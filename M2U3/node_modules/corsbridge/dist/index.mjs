// src/tls.ts
import https from "https";
import { Agent as UndiciAgent, setGlobalDispatcher } from "undici";
var configured = false;
function disableTlsSessionReuse() {
  if (configured) {
    return;
  }
  const agent = https.globalAgent;
  if (agent.options) {
    agent.options.maxCachedSessions = 0;
  }
  if (typeof agent.maxCachedSessions === "number") {
    agent.maxCachedSessions = 0;
  }
  try {
    const dispatcher = new UndiciAgent({
      connect: {
        maxCachedSessions: 0
      },
      pipelining: 0
    });
    setGlobalDispatcher(dispatcher);
  } catch (error) {
    console.warn("Failed to configure undici TLS guard", error);
  }
  configured = true;
}
disableTlsSessionReuse();

// src/types.ts
var ErrorType = /* @__PURE__ */ ((ErrorType2) => {
  ErrorType2["VALIDATION"] = "ValidationError";
  ErrorType2["RATE_LIMIT"] = "RateLimitError";
  ErrorType2["PAYLOAD_TOO_LARGE"] = "PayloadTooLargeError";
  ErrorType2["BAD_GATEWAY"] = "BadGatewayError";
  ErrorType2["GATEWAY_TIMEOUT"] = "GatewayTimeoutError";
  ErrorType2["HTTP_ERROR"] = "HttpError";
  ErrorType2["NETWORK_ERROR"] = "NetworkError";
  return ErrorType2;
})(ErrorType || {});

// src/errors.ts
var CorsBridgeError = class _CorsBridgeError extends Error {
  constructor(message, type, statusCode, details, requestId, traceId, spanId) {
    super(message);
    this.name = "CorsBridgeError";
    this.type = type;
    this.statusCode = statusCode;
    this.details = details;
    this.requestId = requestId;
    this.traceId = traceId;
    this.spanId = spanId;
    Object.setPrototypeOf(this, _CorsBridgeError.prototype);
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      type: this.type,
      statusCode: this.statusCode,
      details: this.details,
      requestId: this.requestId,
      traceId: this.traceId,
      spanId: this.spanId
    };
  }
};
var ValidationError = class _ValidationError extends CorsBridgeError {
  constructor(message, statusCode = 400, details) {
    super(message, "ValidationError" /* VALIDATION */, statusCode, details);
    this.name = "ValidationError";
    Object.setPrototypeOf(this, _ValidationError.prototype);
  }
};
var RateLimitError = class _RateLimitError extends CorsBridgeError {
  constructor(message, details) {
    super(message, "RateLimitError" /* RATE_LIMIT */, 429, details);
    this.name = "RateLimitError";
    Object.setPrototypeOf(this, _RateLimitError.prototype);
  }
};
var PayloadTooLargeError = class _PayloadTooLargeError extends CorsBridgeError {
  constructor(message, details) {
    super(message, "PayloadTooLargeError" /* PAYLOAD_TOO_LARGE */, 413, details);
    this.name = "PayloadTooLargeError";
    Object.setPrototypeOf(this, _PayloadTooLargeError.prototype);
  }
};
var BadGatewayError = class _BadGatewayError extends CorsBridgeError {
  constructor(message, details) {
    super(message, "BadGatewayError" /* BAD_GATEWAY */, 502, details);
    this.name = "BadGatewayError";
    Object.setPrototypeOf(this, _BadGatewayError.prototype);
  }
};
var GatewayTimeoutError = class _GatewayTimeoutError extends CorsBridgeError {
  constructor(message, details) {
    super(message, "GatewayTimeoutError" /* GATEWAY_TIMEOUT */, 504, details);
    this.name = "GatewayTimeoutError";
    Object.setPrototypeOf(this, _GatewayTimeoutError.prototype);
  }
};
var NetworkError = class _NetworkError extends CorsBridgeError {
  constructor(message, details) {
    super(message, "NetworkError" /* NETWORK_ERROR */, 0, details);
    this.name = "NetworkError";
    Object.setPrototypeOf(this, _NetworkError.prototype);
  }
};
var HostBlockedError = class _HostBlockedError extends ValidationError {
  constructor(message, details) {
    super(message, 403, details);
    this.name = "HostBlockedError";
    Object.setPrototypeOf(this, _HostBlockedError.prototype);
  }
};
var SSRFBlockedError = class _SSRFBlockedError extends ValidationError {
  constructor(message, details) {
    super(message, 403, details);
    this.name = "SSRFBlockedError";
    Object.setPrototypeOf(this, _SSRFBlockedError.prototype);
  }
};
var InvalidURLError = class _InvalidURLError extends ValidationError {
  constructor(message, details) {
    super(message, 414, details);
    this.name = "InvalidURLError";
    Object.setPrototypeOf(this, _InvalidURLError.prototype);
  }
};
var TimeoutError = class _TimeoutError extends GatewayTimeoutError {
  constructor(message, details) {
    super(message, details);
    this.name = "TimeoutError";
    Object.setPrototypeOf(this, _TimeoutError.prototype);
  }
};
var TargetError = class _TargetError extends BadGatewayError {
  constructor(message, details) {
    super(message, details);
    this.name = "TargetError";
    Object.setPrototypeOf(this, _TargetError.prototype);
  }
};
function createErrorFromResponse(errorData, statusCode) {
  const message = errorData.message || "Unknown error";
  const details = errorData.details;
  const requestId = errorData.requestId;
  const traceId = errorData.traceId;
  const spanId = errorData.spanId;
  const setMetadata = (error) => {
    error.requestId = requestId;
    error.traceId = traceId;
    error.spanId = spanId;
    return error;
  };
  if (statusCode === 400 || statusCode === 403 || statusCode === 414) {
    const lowerMessage = message.toLowerCase();
    if (statusCode === 400 && (lowerMessage.includes("unable to resolve") || lowerMessage.includes("dns") || lowerMessage.includes("hostname"))) {
      return setMetadata(new NetworkError(message, details));
    }
    if (statusCode === 403) {
      if (details?.reason === "ssrf_attempt") {
        return setMetadata(new SSRFBlockedError(message, details));
      }
      if (details?.reason === "host_blocked") {
        return setMetadata(new HostBlockedError(message, details));
      }
      if (message.includes("169.254") || lowerMessage.includes("metadata") || lowerMessage.includes("ssrf") || details?.hostname?.includes(".local") || details?.hostname?.includes(".internal") || details?.hostname?.includes(".intranet")) {
        return setMetadata(new SSRFBlockedError(message, details));
      }
      if (lowerMessage.includes("not reachable") || lowerMessage.includes("private") || lowerMessage.includes("internal") || lowerMessage.includes("blocked") || lowerMessage.includes("localhost") || details?.address) {
        return setMetadata(new HostBlockedError(message, details));
      }
      return setMetadata(new ValidationError(message, statusCode, details));
    }
    if (statusCode === 414 && (lowerMessage.includes("url exceeds") || lowerMessage.includes("too long") || lowerMessage.includes("maximum allowed length"))) {
      return setMetadata(new InvalidURLError(message, details));
    }
    return setMetadata(new ValidationError(message, statusCode, details));
  }
  switch (statusCode) {
    case 413:
      return setMetadata(new PayloadTooLargeError(message, details));
    case 429:
      return setMetadata(new RateLimitError(message, details));
    case 502:
      const lowerMsg = message.toLowerCase();
      if (lowerMsg.includes("not reachable") || lowerMsg.includes("connection") || lowerMsg.includes("redirect")) {
        return setMetadata(new BadGatewayError(message, details));
      }
      return setMetadata(new TargetError(message, details));
    case 504:
      if (message.toLowerCase().includes("timeout")) {
        return setMetadata(new TimeoutError(message, details));
      }
      return setMetadata(new GatewayTimeoutError(message, details));
    default:
      if (statusCode >= 500 && statusCode < 600) {
        return setMetadata(new TargetError(message, details));
      }
      return new CorsBridgeError(
        message,
        "HttpError" /* HTTP_ERROR */,
        statusCode,
        details,
        requestId,
        traceId,
        spanId
      );
  }
}

// src/corsFetch.ts
var DEFAULT_PROXY_ENDPOINT = "https://api.cors.syrins.tech";
var timeoutLikeErrorCodes = /* @__PURE__ */ new Set([
  "UND_ERR_CONNECT_TIMEOUT",
  "UND_ERR_HEADERS_TIMEOUT",
  "UND_ERR_BODY_TIMEOUT",
  "UND_ERR_ABORTED",
  "ECONNRESET",
  "ETIMEDOUT",
  "ECONNABORTED"
]);
var CONTENT_TYPE_HEADER = "Content-Type";
function getProxyURL(override) {
  if (override && override.trim().length > 0) {
    return override.trim().replace(/\/?$/, "");
  }
  const envTarget = process.env.CORS_PROXY_URL?.trim();
  return (envTarget && envTarget.length > 0 ? envTarget : DEFAULT_PROXY_ENDPOINT).replace(/\/?$/, "");
}
function buildQueryString(params) {
  const searchParams = new URLSearchParams();
  Object.entries(params).forEach(([key, value]) => {
    searchParams.append(key, String(value));
  });
  return searchParams.toString();
}
function validateURL(url) {
  if (!url || typeof url !== "string") {
    throw new ValidationError("URL must be a non-empty string");
  }
  if (!url.trim()) {
    throw new ValidationError("URL cannot be empty");
  }
  if (!/^https?:\/\/.+/i.test(url.trim())) {
    throw new ValidationError("URL must start with http:// or https://");
  }
}
function buildProxyURL(targetUrl, params, proxyOverride) {
  validateURL(targetUrl);
  let finalUrl = targetUrl.trim();
  if (params && Object.keys(params).length > 0) {
    const queryString = buildQueryString(params);
    const separator = finalUrl.includes("?") ? "&" : "?";
    finalUrl = `${finalUrl}${separator}${queryString}`;
  }
  const encodedUrl = encodeURIComponent(finalUrl);
  return `${getProxyURL(proxyOverride)}/?url=${encodedUrl}`;
}
function findContentTypeHeader(headers) {
  return Object.keys(headers).find((key) => key.toLowerCase() === "content-type") ?? null;
}
function setContentType(headers, value) {
  const existingKey = findContentTypeHeader(headers);
  if (existingKey) {
    headers[existingKey] = value;
  } else {
    headers[CONTENT_TYPE_HEADER] = value;
  }
}
function deleteContentType(headers) {
  const existingKey = findContentTypeHeader(headers);
  if (existingKey) {
    delete headers[existingKey];
  }
}
async function fetchWithTimeout(url, options, timeout) {
  if (!timeout) {
    return fetch(url, options);
  }
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);
  try {
    const response = await fetch(url, {
      ...options,
      signal: controller.signal
    });
    clearTimeout(timeoutId);
    return response;
  } catch (error) {
    clearTimeout(timeoutId);
    if (error.name === "AbortError") {
      throw new TimeoutError(`Request timeout after ${timeout}ms`);
    }
    throw error;
  }
}
async function processResponse(response, responseType = "json") {
  switch (responseType) {
    case "text":
      return await response.text();
    case "arrayBuffer":
      return await response.arrayBuffer();
    case "blob":
      return await response.blob();
    case "json":
    default:
      const text = await response.text();
      try {
        return JSON.parse(text);
      } catch {
        return text;
      }
  }
}
async function corsFetch(targetUrl, options = {}) {
  const {
    method = "GET",
    headers = {},
    body,
    params,
    timeout,
    responseType = "json",
    proxyUrl
  } = options;
  const resolvedHeaders = { ...headers };
  let resolvedBody;
  if (body !== void 0) {
    if (typeof body === "string") {
      resolvedBody = body;
      if (!findContentTypeHeader(resolvedHeaders)) {
        setContentType(resolvedHeaders, "text/plain;charset=UTF-8");
      }
    } else if (body instanceof FormData || body instanceof Blob || body instanceof ArrayBuffer || body instanceof URLSearchParams) {
      resolvedBody = body;
      if (body instanceof FormData) {
        deleteContentType(resolvedHeaders);
      }
    } else {
      resolvedBody = JSON.stringify(body);
      if (!findContentTypeHeader(resolvedHeaders)) {
        setContentType(resolvedHeaders, "application/json");
      }
    }
  }
  const fetchOptions = {
    method,
    headers: Object.keys(resolvedHeaders).length > 0 ? resolvedHeaders : void 0,
    body: resolvedBody
  };
  const proxyEndpoint = buildProxyURL(targetUrl, params, proxyUrl);
  try {
    const response = await fetchWithTimeout(proxyEndpoint, fetchOptions, timeout);
    if (!response.ok) {
      const errorData = await response.json().catch(() => ({
        error: true,
        message: `HTTP ${response.status}: ${response.statusText}`,
        statusCode: response.status
      }));
      throw createErrorFromResponse(errorData, response.status);
    }
    return await processResponse(response, responseType);
  } catch (error) {
    if (error instanceof CorsBridgeError) {
      throw error;
    }
    if (error instanceof TypeError && error.message.includes("fetch")) {
      const errorCode = extractErrorCode(error);
      if (isTimeoutLikeError(error, errorCode)) {
        throw new TimeoutError("Network request timed out before proxy responded", {
          code: errorCode,
          originalMessage: error.message
        });
      }
      throw new NetworkError("Network request failed", {
        originalMessage: error.message,
        errorName: error.name,
        code: errorCode
      });
    }
    throw error;
  }
}
function extractErrorCode(error) {
  return (error && typeof error === "object" && "code" in error ? error.code : void 0) ?? (error?.cause && typeof error.cause === "object" && "code" in error.cause ? error.cause.code : void 0);
}
function isTimeoutLikeError(error, code) {
  if (code && timeoutLikeErrorCodes.has(code)) {
    return true;
  }
  return /timeout|timed out|aborted|socket hang up/i.test(error.message);
}
var corsGet = (url, options) => corsFetch(url, { ...options, method: "GET" });
var corsPost = (url, body, options) => corsFetch(url, { ...options, method: "POST", body });
var corsPut = (url, body, options) => corsFetch(url, { ...options, method: "PUT", body });
var corsPatch = (url, body, options) => corsFetch(url, { ...options, method: "PATCH", body });
var corsDelete = (url, options) => corsFetch(url, { ...options, method: "DELETE" });
export {
  BadGatewayError,
  CorsBridgeError,
  ErrorType,
  GatewayTimeoutError,
  HostBlockedError,
  InvalidURLError,
  NetworkError,
  PayloadTooLargeError,
  RateLimitError,
  SSRFBlockedError,
  TargetError,
  TimeoutError,
  ValidationError,
  corsDelete,
  corsFetch,
  corsGet,
  corsPatch,
  corsPost,
  corsPut
};
//# sourceMappingURL=index.mjs.map