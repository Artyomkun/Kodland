#!/usr/bin/env node

// src/cli.ts
import fs from "fs";
import path from "path";

// src/tls.ts
import https from "https";
import { Agent as UndiciAgent, setGlobalDispatcher } from "undici";
var configured = false;
function disableTlsSessionReuse() {
  if (configured) {
    return;
  }
  const agent = https.globalAgent;
  if (agent.options) {
    agent.options.maxCachedSessions = 0;
  }
  if (typeof agent.maxCachedSessions === "number") {
    agent.maxCachedSessions = 0;
  }
  try {
    const dispatcher = new UndiciAgent({
      connect: {
        maxCachedSessions: 0
      },
      pipelining: 0
    });
    setGlobalDispatcher(dispatcher);
  } catch (error) {
    console.warn("Failed to configure undici TLS guard", error);
  }
  configured = true;
}
disableTlsSessionReuse();

// src/errors.ts
var CorsBridgeError = class _CorsBridgeError extends Error {
  constructor(message, type, statusCode, details, requestId, traceId, spanId) {
    super(message);
    this.name = "CorsBridgeError";
    this.type = type;
    this.statusCode = statusCode;
    this.details = details;
    this.requestId = requestId;
    this.traceId = traceId;
    this.spanId = spanId;
    Object.setPrototypeOf(this, _CorsBridgeError.prototype);
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      type: this.type,
      statusCode: this.statusCode,
      details: this.details,
      requestId: this.requestId,
      traceId: this.traceId,
      spanId: this.spanId
    };
  }
};
var ValidationError = class _ValidationError extends CorsBridgeError {
  constructor(message, statusCode = 400, details) {
    super(message, "ValidationError" /* VALIDATION */, statusCode, details);
    this.name = "ValidationError";
    Object.setPrototypeOf(this, _ValidationError.prototype);
  }
};
var RateLimitError = class _RateLimitError extends CorsBridgeError {
  constructor(message, details) {
    super(message, "RateLimitError" /* RATE_LIMIT */, 429, details);
    this.name = "RateLimitError";
    Object.setPrototypeOf(this, _RateLimitError.prototype);
  }
};
var PayloadTooLargeError = class _PayloadTooLargeError extends CorsBridgeError {
  constructor(message, details) {
    super(message, "PayloadTooLargeError" /* PAYLOAD_TOO_LARGE */, 413, details);
    this.name = "PayloadTooLargeError";
    Object.setPrototypeOf(this, _PayloadTooLargeError.prototype);
  }
};
var BadGatewayError = class _BadGatewayError extends CorsBridgeError {
  constructor(message, details) {
    super(message, "BadGatewayError" /* BAD_GATEWAY */, 502, details);
    this.name = "BadGatewayError";
    Object.setPrototypeOf(this, _BadGatewayError.prototype);
  }
};
var GatewayTimeoutError = class _GatewayTimeoutError extends CorsBridgeError {
  constructor(message, details) {
    super(message, "GatewayTimeoutError" /* GATEWAY_TIMEOUT */, 504, details);
    this.name = "GatewayTimeoutError";
    Object.setPrototypeOf(this, _GatewayTimeoutError.prototype);
  }
};
var NetworkError = class _NetworkError extends CorsBridgeError {
  constructor(message, details) {
    super(message, "NetworkError" /* NETWORK_ERROR */, 0, details);
    this.name = "NetworkError";
    Object.setPrototypeOf(this, _NetworkError.prototype);
  }
};
var HostBlockedError = class _HostBlockedError extends ValidationError {
  constructor(message, details) {
    super(message, 403, details);
    this.name = "HostBlockedError";
    Object.setPrototypeOf(this, _HostBlockedError.prototype);
  }
};
var SSRFBlockedError = class _SSRFBlockedError extends ValidationError {
  constructor(message, details) {
    super(message, 403, details);
    this.name = "SSRFBlockedError";
    Object.setPrototypeOf(this, _SSRFBlockedError.prototype);
  }
};
var InvalidURLError = class _InvalidURLError extends ValidationError {
  constructor(message, details) {
    super(message, 414, details);
    this.name = "InvalidURLError";
    Object.setPrototypeOf(this, _InvalidURLError.prototype);
  }
};
var TimeoutError = class _TimeoutError extends GatewayTimeoutError {
  constructor(message, details) {
    super(message, details);
    this.name = "TimeoutError";
    Object.setPrototypeOf(this, _TimeoutError.prototype);
  }
};
var TargetError = class _TargetError extends BadGatewayError {
  constructor(message, details) {
    super(message, details);
    this.name = "TargetError";
    Object.setPrototypeOf(this, _TargetError.prototype);
  }
};
function createErrorFromResponse(errorData, statusCode) {
  var _a, _b, _c;
  const message = errorData.message || "Unknown error";
  const details = errorData.details;
  const requestId = errorData.requestId;
  const traceId = errorData.traceId;
  const spanId = errorData.spanId;
  const setMetadata = (error) => {
    error.requestId = requestId;
    error.traceId = traceId;
    error.spanId = spanId;
    return error;
  };
  if (statusCode === 400 || statusCode === 403 || statusCode === 414) {
    const lowerMessage = message.toLowerCase();
    if (statusCode === 400 && (lowerMessage.includes("unable to resolve") || lowerMessage.includes("dns") || lowerMessage.includes("hostname"))) {
      return setMetadata(new NetworkError(message, details));
    }
    if (statusCode === 403) {
      if ((details == null ? void 0 : details.reason) === "ssrf_attempt") {
        return setMetadata(new SSRFBlockedError(message, details));
      }
      if ((details == null ? void 0 : details.reason) === "host_blocked") {
        return setMetadata(new HostBlockedError(message, details));
      }
      if (message.includes("169.254") || lowerMessage.includes("metadata") || lowerMessage.includes("ssrf") || ((_a = details == null ? void 0 : details.hostname) == null ? void 0 : _a.includes(".local")) || ((_b = details == null ? void 0 : details.hostname) == null ? void 0 : _b.includes(".internal")) || ((_c = details == null ? void 0 : details.hostname) == null ? void 0 : _c.includes(".intranet"))) {
        return setMetadata(new SSRFBlockedError(message, details));
      }
      if (lowerMessage.includes("not reachable") || lowerMessage.includes("private") || lowerMessage.includes("internal") || lowerMessage.includes("blocked") || lowerMessage.includes("localhost") || (details == null ? void 0 : details.address)) {
        return setMetadata(new HostBlockedError(message, details));
      }
      return setMetadata(new ValidationError(message, statusCode, details));
    }
    if (statusCode === 414 && (lowerMessage.includes("url exceeds") || lowerMessage.includes("too long") || lowerMessage.includes("maximum allowed length"))) {
      return setMetadata(new InvalidURLError(message, details));
    }
    return setMetadata(new ValidationError(message, statusCode, details));
  }
  switch (statusCode) {
    case 413:
      return setMetadata(new PayloadTooLargeError(message, details));
    case 429:
      return setMetadata(new RateLimitError(message, details));
    case 502:
      const lowerMsg = message.toLowerCase();
      if (lowerMsg.includes("not reachable") || lowerMsg.includes("connection") || lowerMsg.includes("redirect")) {
        return setMetadata(new BadGatewayError(message, details));
      }
      return setMetadata(new TargetError(message, details));
    case 504:
      if (message.toLowerCase().includes("timeout")) {
        return setMetadata(new TimeoutError(message, details));
      }
      return setMetadata(new GatewayTimeoutError(message, details));
    default:
      if (statusCode >= 500 && statusCode < 600) {
        return setMetadata(new TargetError(message, details));
      }
      return new CorsBridgeError(
        message,
        "HttpError" /* HTTP_ERROR */,
        statusCode,
        details,
        requestId,
        traceId,
        spanId
      );
  }
}

// src/corsFetch.ts
var DEFAULT_PROXY_ENDPOINT = "https://api.cors.syrins.tech";
var timeoutLikeErrorCodes = /* @__PURE__ */ new Set([
  "UND_ERR_CONNECT_TIMEOUT",
  "UND_ERR_HEADERS_TIMEOUT",
  "UND_ERR_BODY_TIMEOUT",
  "UND_ERR_ABORTED",
  "ECONNRESET",
  "ETIMEDOUT",
  "ECONNABORTED"
]);
var CONTENT_TYPE_HEADER = "Content-Type";
function getProxyURL(override) {
  var _a;
  if (override && override.trim().length > 0) {
    return override.trim().replace(/\/?$/, "");
  }
  const envTarget = (_a = process.env.CORS_PROXY_URL) == null ? void 0 : _a.trim();
  return (envTarget && envTarget.length > 0 ? envTarget : DEFAULT_PROXY_ENDPOINT).replace(/\/?$/, "");
}
function buildQueryString(params) {
  const searchParams = new URLSearchParams();
  Object.entries(params).forEach(([key, value]) => {
    searchParams.append(key, String(value));
  });
  return searchParams.toString();
}
function validateURL(url) {
  if (!url || typeof url !== "string") {
    throw new ValidationError("URL must be a non-empty string");
  }
  if (!url.trim()) {
    throw new ValidationError("URL cannot be empty");
  }
  if (!/^https?:\/\/.+/i.test(url.trim())) {
    throw new ValidationError("URL must start with http:// or https://");
  }
}
function buildProxyURL(targetUrl, params, proxyOverride) {
  validateURL(targetUrl);
  let finalUrl = targetUrl.trim();
  if (params && Object.keys(params).length > 0) {
    const queryString = buildQueryString(params);
    const separator = finalUrl.includes("?") ? "&" : "?";
    finalUrl = `${finalUrl}${separator}${queryString}`;
  }
  const encodedUrl = encodeURIComponent(finalUrl);
  return `${getProxyURL(proxyOverride)}/?url=${encodedUrl}`;
}
function findContentTypeHeader(headers) {
  return Object.keys(headers).find((key) => key.toLowerCase() === "content-type") ?? null;
}
function setContentType(headers, value) {
  const existingKey = findContentTypeHeader(headers);
  if (existingKey) {
    headers[existingKey] = value;
  } else {
    headers[CONTENT_TYPE_HEADER] = value;
  }
}
function deleteContentType(headers) {
  const existingKey = findContentTypeHeader(headers);
  if (existingKey) {
    delete headers[existingKey];
  }
}
async function fetchWithTimeout(url, options, timeout) {
  if (!timeout) {
    return fetch(url, options);
  }
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);
  try {
    const response = await fetch(url, {
      ...options,
      signal: controller.signal
    });
    clearTimeout(timeoutId);
    return response;
  } catch (error) {
    clearTimeout(timeoutId);
    if (error.name === "AbortError") {
      throw new TimeoutError(`Request timeout after ${timeout}ms`);
    }
    throw error;
  }
}
async function processResponse(response, responseType = "json") {
  switch (responseType) {
    case "text":
      return await response.text();
    case "arrayBuffer":
      return await response.arrayBuffer();
    case "blob":
      return await response.blob();
    case "json":
    default:
      const text = await response.text();
      try {
        return JSON.parse(text);
      } catch {
        return text;
      }
  }
}
async function corsFetch(targetUrl, options = {}) {
  const {
    method = "GET",
    headers = {},
    body,
    params,
    timeout,
    responseType = "json",
    proxyUrl
  } = options;
  const resolvedHeaders = { ...headers };
  let resolvedBody;
  if (body !== void 0) {
    if (typeof body === "string") {
      resolvedBody = body;
      if (!findContentTypeHeader(resolvedHeaders)) {
        setContentType(resolvedHeaders, "text/plain;charset=UTF-8");
      }
    } else if (body instanceof FormData || body instanceof Blob || body instanceof ArrayBuffer || body instanceof URLSearchParams) {
      resolvedBody = body;
      if (body instanceof FormData) {
        deleteContentType(resolvedHeaders);
      }
    } else {
      resolvedBody = JSON.stringify(body);
      if (!findContentTypeHeader(resolvedHeaders)) {
        setContentType(resolvedHeaders, "application/json");
      }
    }
  }
  const fetchOptions = {
    method,
    headers: Object.keys(resolvedHeaders).length > 0 ? resolvedHeaders : void 0,
    body: resolvedBody
  };
  const proxyEndpoint = buildProxyURL(targetUrl, params, proxyUrl);
  try {
    const response = await fetchWithTimeout(proxyEndpoint, fetchOptions, timeout);
    if (!response.ok) {
      const errorData = await response.json().catch(() => ({
        error: true,
        message: `HTTP ${response.status}: ${response.statusText}`,
        statusCode: response.status
      }));
      throw createErrorFromResponse(errorData, response.status);
    }
    return await processResponse(response, responseType);
  } catch (error) {
    if (error instanceof CorsBridgeError) {
      throw error;
    }
    if (error instanceof TypeError && error.message.includes("fetch")) {
      const errorCode = extractErrorCode(error);
      if (isTimeoutLikeError(error, errorCode)) {
        throw new TimeoutError("Network request timed out before proxy responded", {
          code: errorCode,
          originalMessage: error.message
        });
      }
      throw new NetworkError("Network request failed", {
        originalMessage: error.message,
        errorName: error.name,
        code: errorCode
      });
    }
    throw error;
  }
}
function extractErrorCode(error) {
  return (error && typeof error === "object" && "code" in error ? error.code : void 0) ?? ((error == null ? void 0 : error.cause) && typeof error.cause === "object" && "code" in error.cause ? error.cause.code : void 0);
}
function isTimeoutLikeError(error, code) {
  if (code && timeoutLikeErrorCodes.has(code)) {
    return true;
  }
  return /timeout|timed out|aborted|socket hang up/i.test(error.message);
}

// src/cli.ts
var VERSION = "1.2.0";
function printHelp() {
  console.log(`
\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557
\u2551                      CorsBridge CLI                      \u2551
\u2551           Zero-Config CORS Proxy for Developers          \u2551
\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D

Usage:
  corsbridge <url> [options]

Options:
  -X, --method <method>      HTTP method (GET, POST, PUT, DELETE, etc.)
  -H, --header <header>      Add header (can be used multiple times)
  -d, --data <data>          Request body (JSON string or @file)
  -t, --timeout <ms>         Request timeout in milliseconds
  --proxy <url>             Override proxy endpoint (defaults to env/CorsBridge cloud)
  -v, --verbose              Show detailed response information
  -h, --help                 Show this help message
  --version                  Show version number

Examples:
  # Simple GET request
  corsbridge https://api.github.com/users/github

  # POST request with JSON body
  corsbridge https://api.example.com/users -X POST -d '{"name":"John"}'

  # With custom headers
  corsbridge https://api.example.com/data -H "Authorization: Bearer TOKEN"

  # Verbose output
  corsbridge https://api.example.com/data -v

Learn more:
  \u{1F4E6} NPM: https://www.npmjs.com/package/corsbridge
  \u{1F310} Website: https://cors.syrins.tech
  \u{1F4BB} GitHub: https://github.com/syrins/corsbridge
`);
}
function printVersion() {
  console.log(`corsbridge v${VERSION}`);
}
function parseArgs(args) {
  var _a;
  if (args.length === 0) {
    printHelp();
    return null;
  }
  const options = {
    url: "",
    headers: {}
  };
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    switch (arg) {
      case "-h":
      case "--help":
        printHelp();
        return null;
      case "--version":
        printVersion();
        return null;
      case "-X":
      case "--method":
        options.method = (_a = args[++i]) == null ? void 0 : _a.toUpperCase();
        break;
      case "-H":
      case "--header":
        const header = args[++i];
        if (header) {
          const [key, ...valueParts] = header.split(":");
          options.headers[key.trim()] = valueParts.join(":").trim();
        }
        break;
      case "--proxy":
        options.proxyUrl = args[++i];
        break;
      case "-d":
      case "--data": {
        const dataArg = args[++i];
        if (dataArg == null ? void 0 : dataArg.startsWith("@")) {
          const filePath = dataArg.slice(1);
          if (!filePath) {
            console.error("\u274C Error: Data file path is required after @");
            return null;
          }
          try {
            const absolute = path.resolve(process.cwd(), filePath);
            options.data = fs.readFileSync(absolute, "utf-8");
          } catch (error) {
            console.error(`\u274C Error: Unable to read data file "${filePath}"`);
            if (error instanceof Error) {
              console.error(error.message);
            }
            return null;
          }
        } else {
          options.data = dataArg;
        }
        break;
      }
      case "-t":
      case "--timeout":
        options.timeout = parseInt(args[++i], 10);
        break;
      case "-v":
      case "--verbose":
        options.verbose = true;
        break;
      default:
        if (!options.url && !arg.startsWith("-")) {
          options.url = arg;
        }
    }
  }
  if (!options.url) {
    console.error("\u274C Error: URL is required\n");
    printHelp();
    return null;
  }
  return options;
}
async function main() {
  const args = process.argv.slice(2);
  const options = parseArgs(args);
  if (!options) {
    process.exit(0);
  }
  try {
    console.log(`\u{1F310} Fetching: ${options.url}
`);
    const startTime = Date.now();
    const requestOptions = {
      method: options.method || (options.data ? "POST" : "GET"),
      headers: Object.keys(options.headers || {}).length > 0 ? options.headers : void 0,
      timeout: options.timeout,
      proxyUrl: options.proxyUrl
    };
    if (options.data) {
      try {
        requestOptions.body = JSON.parse(options.data);
      } catch {
        requestOptions.body = options.data;
      }
    }
    const response = await corsFetch(options.url, requestOptions);
    const duration = Date.now() - startTime;
    if (options.verbose) {
      console.log("\u2705 Success!\n");
      console.log(`\u23F1\uFE0F  Duration: ${duration}ms`);
      console.log(`\u{1F4DD} Method: ${requestOptions.method}`);
      console.log(`\u{1F517} URL: ${options.url}
`);
      console.log("\u{1F4E6} Response:");
    }
    if (typeof response === "object") {
      console.log(JSON.stringify(response, null, 2));
    } else {
      console.log(response);
    }
    process.exit(0);
  } catch (error) {
    console.error("\n\u274C Error occurred:\n");
    if (error instanceof CorsBridgeError) {
      console.error(`Type: ${error.name}`);
      console.error(`Message: ${error.message}`);
      if (error.requestId || error.traceId || error.spanId) {
        console.error("\nRequest metadata:");
        if (error.requestId) {
          console.error(`  Request ID: ${error.requestId}`);
        }
        if (error.traceId) {
          console.error(`  Trace ID: ${error.traceId}`);
        }
        if (error.spanId) {
          console.error(`  Span ID: ${error.spanId}`);
        }
      }
      if (error.details) {
        console.error("\nDetails:");
        if (error.details.code) {
          console.error(`  Error Code: ${error.details.code}`);
        }
        if (error.details.blockedUrl) {
          console.error(`  Blocked URL: ${error.details.blockedUrl}`);
        }
        if (error.details.retryAfter) {
          console.error(`  Retry After: ${error.details.retryAfter}s`);
        }
        const extraEntries = Object.entries(error.details).filter(
          ([key]) => !["requestId", "traceId", "spanId", "code", "blockedUrl", "retryAfter"].includes(key)
        );
        if (extraEntries.length > 0) {
          for (const [key, value] of extraEntries) {
            console.error(`  ${key}: ${JSON.stringify(value)}`);
          }
        }
      }
    } else if (error instanceof Error) {
      console.error(error.message);
    } else {
      console.error(String(error));
    }
    console.error("\n\u{1F4A1} Need help? Visit https://cors.syrins.tech/docs\n");
    process.exit(1);
  }
}
main();
