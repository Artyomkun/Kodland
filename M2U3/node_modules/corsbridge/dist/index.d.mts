/**
 * CorsBridge Request Options
 */
interface CorsFetchOptions {
    /** HTTP method (GET, POST, PUT, PATCH, DELETE, etc.) */
    method?: string;
    /** Request headers */
    headers?: Record<string, string>;
    /** Request body (JSON object, FormData, string, etc.) */
    body?: any;
    /** Query parameters to append to URL */
    params?: Record<string, string | number | boolean>;
    /** Request timeout in milliseconds */
    timeout?: number;
    /** Expected response type */
    responseType?: 'json' | 'text' | 'arrayBuffer' | 'blob';
    /** Override proxy endpoint for this request */
    proxyUrl?: string;
}
/**
 * CorsBridge Error Response (Backend format)
 */
interface ErrorResponse {
    error: boolean;
    message: string;
    statusCode: number;
    requestId?: string;
    traceId?: string;
    spanId?: string;
    timestamp?: string;
    details?: Record<string, unknown>;
}
/**
 * CorsBridge Response (generic type for successful responses)
 */
type CorsBridgeResponse<T = any> = T;
/**
 * CorsBridge Error Details
 */
interface CorsBridgeErrorDetails {
    requestId?: string;
    traceId?: string;
    spanId?: string;
    code?: string;
    retryAfter?: number;
    blockedUrl?: string;
    [key: string]: any;
}
/**
 * Alias for CorsFetchOptions (for backwards compatibility and clarity)
 */
type CorsBridgeOptions = CorsFetchOptions;
/**
 * Error types mapped from backend
 */
declare enum ErrorType {
    VALIDATION = "ValidationError",
    RATE_LIMIT = "RateLimitError",
    PAYLOAD_TOO_LARGE = "PayloadTooLargeError",
    BAD_GATEWAY = "BadGatewayError",
    GATEWAY_TIMEOUT = "GatewayTimeoutError",
    HTTP_ERROR = "HttpError",
    NETWORK_ERROR = "NetworkError"
}

/**
 * Main corsFetch function
 *
 * @param targetUrl - The URL to fetch (will be proxied through CorsBridge)
 * @param options - Request options
 * @returns Promise with the response data
 *
 * @example
 * ```ts
 * const data = await corsFetch('https://api.example.com/users');
 * ```
 *
 * @example
 * ```ts
 * const data = await corsFetch('https://api.example.com/users', {
 *   method: 'POST',
 *   body: { name: 'John' },
 *   headers: { 'Authorization': 'Bearer token' }
 * });
 * ```
 */
declare function corsFetch<T = any>(targetUrl: string, options?: CorsFetchOptions): Promise<T>;
/**
 * Convenience methods for different HTTP methods
 */
declare const corsGet: <T = any>(url: string, options?: Omit<CorsFetchOptions, "method">) => Promise<T>;
declare const corsPost: <T = any>(url: string, body?: any, options?: Omit<CorsFetchOptions, "method" | "body">) => Promise<T>;
declare const corsPut: <T = any>(url: string, body?: any, options?: Omit<CorsFetchOptions, "method" | "body">) => Promise<T>;
declare const corsPatch: <T = any>(url: string, body?: any, options?: Omit<CorsFetchOptions, "method" | "body">) => Promise<T>;
declare const corsDelete: <T = any>(url: string, options?: Omit<CorsFetchOptions, "method">) => Promise<T>;

/**
 * Base CorsBridge Error
 */
declare class CorsBridgeError extends Error {
    readonly type: string;
    readonly statusCode: number;
    readonly details?: CorsBridgeErrorDetails;
    requestId?: string;
    traceId?: string;
    spanId?: string;
    constructor(message: string, type: string, statusCode: number, details?: CorsBridgeErrorDetails, requestId?: string, traceId?: string, spanId?: string);
    toJSON(): {
        name: string;
        message: string;
        type: string;
        statusCode: number;
        details: CorsBridgeErrorDetails | undefined;
        requestId: string | undefined;
        traceId: string | undefined;
        spanId: string | undefined;
    };
}
/**
 * Validation Error (400, 403, 414)
 */
declare class ValidationError extends CorsBridgeError {
    constructor(message: string, statusCode?: number, details?: CorsBridgeErrorDetails);
}
/**
 * Rate limit exceeded (429)
 */
declare class RateLimitError extends CorsBridgeError {
    constructor(message: string, details?: CorsBridgeErrorDetails);
}
/**
 * Payload too large (413)
 */
declare class PayloadTooLargeError extends CorsBridgeError {
    constructor(message: string, details?: CorsBridgeErrorDetails);
}
/**
 * Bad Gateway (502)
 */
declare class BadGatewayError extends CorsBridgeError {
    constructor(message: string, details?: CorsBridgeErrorDetails);
}
/**
 * Gateway Timeout (504)
 */
declare class GatewayTimeoutError extends CorsBridgeError {
    constructor(message: string, details?: CorsBridgeErrorDetails);
}
/**
 * Network error (client-side)
 */
declare class NetworkError extends CorsBridgeError {
    constructor(message: string, details?: CorsBridgeErrorDetails);
}
/**
 * Host Blocked Error (403) - Private IPs, localhost
 */
declare class HostBlockedError extends ValidationError {
    constructor(message: string, details?: CorsBridgeErrorDetails);
}
/**
 * SSRF Blocked Error (403) - SSRF attempts
 */
declare class SSRFBlockedError extends ValidationError {
    constructor(message: string, details?: CorsBridgeErrorDetails);
}
/**
 * Invalid URL Error (414) - URL too long
 */
declare class InvalidURLError extends ValidationError {
    constructor(message: string, details?: CorsBridgeErrorDetails);
}
/**
 * Timeout Error (504) - Request timeout
 * Alias for GatewayTimeoutError
 */
declare class TimeoutError extends GatewayTimeoutError {
    constructor(message: string, details?: CorsBridgeErrorDetails);
}
/**
 * Target Error (502) - Target server error
 * Alias for BadGatewayError
 */
declare class TargetError extends BadGatewayError {
    constructor(message: string, details?: CorsBridgeErrorDetails);
}

export { BadGatewayError, CorsBridgeError, type CorsBridgeErrorDetails, type CorsBridgeOptions, type CorsBridgeResponse, type CorsFetchOptions, type ErrorResponse, ErrorType, GatewayTimeoutError, HostBlockedError, InvalidURLError, NetworkError, PayloadTooLargeError, RateLimitError, SSRFBlockedError, TargetError, TimeoutError, ValidationError, corsDelete, corsFetch, corsGet, corsPatch, corsPost, corsPut };
